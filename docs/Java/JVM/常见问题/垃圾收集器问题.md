:::tip
垃圾收集器相关知识移步：

[垃圾收集策略与算法](/Java/JVM/深入浅出JVM/垃圾收集策略与算法) 

[HotSpot垃圾收集器](/Java/JVM/深入浅出JVM/HotSpot垃圾收集器)
:::

## 简述Java垃圾回收机制?

在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

## GC是什么？为什么要GC

`GC` 是`垃圾收集`的意思（`Gabage Collection`）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，
Java 提供的 `GC` 功能可以自动监测对象是否超过作用域从而达到`自动回收内存`的目的，Java 语言没有提供释放已分配内存的显示操作方法。

## 垃圾回收的优点和原理。并考虑2种回收机制

Java语言最显著的特点就是引入了`垃圾回收机制`，它使java程序员在编写程序时不再考虑内存管理的问题。

由于有这个`垃圾回收机制`，java中的对象不再有`“作用域”`的概念，只有引用的对象才有“作用域”。

垃圾回收机制有效的防止了`内存泄露`，可以有效的使用可使用的内存。垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。

垃圾回收有`分代复制垃圾回收`、`标记垃圾回收`、`增量垃圾回收`。

## 垃圾回收器的基本原理是什么？

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的`地址`、`大小`以及`使用情况`。

通常，GC采用`有向图`的方式记录和管理堆(`heap`)中的所有对象。通过这种方式确定哪些对象是`"可达的"`，哪些对象是`"不可达的"`。当GC确定一些对象为`"不可达"`时，GC就有责任回收这些内存空间。

## 垃圾回收器可以马上回收内存吗？

可以

## 有什么办法主动通知虚拟机进行垃圾回收？

可以手动执行`System.gc()`，通知GC运行，但是Java语言规范并不保证GC一定会执行。

## 你能保证 GC 执行吗？

不能，虽然你可以调用 `System.gc()` 或者 `Runtime.gc()`，但是没有办法保证 GC 的执行。

## Java 中都有哪些引用类型？

* **强引用**：发生 gc 的时候不会被回收。
* **软引用**：有用但不是必须的对象，在发生内存溢出之前会被回收。
* **弱引用**：有用但不是必须的对象，在下一次GC时会被回收。
* **虚引用**（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 `PhantomReference` 实现虚引用，虚引用的用途是在 gc 时返回一个通知。

## 介绍一下强引用、软引用、弱引用、虚引用的区别？

### 强引用

我们平时`new`了一个对象就是`强引用`，例如 `Object obj = new Object();` 即使在内存不足的情况下，JVM宁愿抛出`OutOfMemory`错误也不会回收这种对象。

### 软引用

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

```java
SoftReference<String> softRef=new SoftReference<String>(str); // 软引用
```

**用处**： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

如下代码：

```java
Browser prev = new Browser(); // 获取页面进行浏览
SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用
if(sr.get()!=null){
    rev = (Browser) sr.get(); // 还没有被回收器回收，直接获取
}else{
    prev = new Browser(); // 由于内存吃紧，所以对软引用的对象回收了
    sr = new SoftReference(prev); // 重新构建
}
```

### 弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

```java
String str=new String("abc");
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
等价于
str = null;
System.gc();
```

### 虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

## 怎么判断对象是否可以被回收？

垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是`「存活」`的，是不可以被回收的；哪些对象已经`「死掉」`了，需要被回收。

一般有两种方法来判断：

* **引用计数器法**：为每个对象创建一个`引用计数`，有对象引用时计数器 `+1`，引用被释放时计数 `-1`，当计数器为 `0` 时就可以被回收。它有一个缺点不能解决`循环引用`的问题；
* **可达性分析算法**：从 `GC Roots` 开始向下搜索，搜索所走过的路径称为`引用链`。当一个对象到 `GC Roots` 没有任何引用链相连时，则证明此对象是可以被回收的。

## 什么是Full GC?

`Full GC`这个概念是没有官方定义的，而且含义还特别混乱，在不同地方表达的含义是不同的，需要就不同的场景分别进行讨论。`Full GC`为一次`特殊GC行为`的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等，

## 永久代会发生垃圾回收吗？

>方法区是一种规范，永久代，元空间是它的具体实现

在Java虚拟机规范中：
![img_18.png](img_18.png)
![img_19.png](img_19.png)

**后续再调研**







