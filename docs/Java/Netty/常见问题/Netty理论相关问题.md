---
outline: { level: [ 2,2 ], }
---

## 1、Netty 是什么？

Netty是一个`异步事件驱动`的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty是基于`nio`的，它封装了jdk的nio，让我们使用起来更加方法灵活。

## 2、JDK原生NIO程序的问题？

JDK原生也有一套网络应用程序API，但是存在一系列问题，主要如下：

1. NIO的类库和API繁杂，使用麻烦，你需要熟练掌握`Selector`、`ServerSocketChannel`、`SocketChannel`、`ByteBuffer`等
2. 需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到`Reactor`模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序
3. 可靠性能力补齐，开发工作量和难度都非常大。
    * 例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大
4. JDK NIO的BUG，例如臭名昭著的`select bug`，它会导致`Selector`空轮询，最终导致CPU 100%。
    * 官方声称在JDK1.6版本的`update18`修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决

## 3、Netty 的优势有哪些？

* **使用简单**：封装了 NIO 的很多细节，使用更简单。
* **功能强大**：预置了多种编解码功能，支持多种主流协议。
* **定制能力强**：可以通过 `ChannelHandler` 对通信框架进行灵活地扩展。
* **性能高**：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。
* **稳定**：Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务本身。
* **社区活跃**：Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快。

## 4、Netty 的应用场景有哪些？

### 典型的应用有：

* 阿里分布式服务框架 `Dubbo`，默认使用 Netty 作为基础通信组件。
* `RocketMQ` 也是使用 Netty 作为通讯的基础。

### Netty常见的使用场景如下：

* **互联网行业**: 在分布式系统中，各个节点之间需要远程服务调用，高性能的`RPC`框架必不可少，Netty作为异步高新能的通信框架,往往作为基础通信组件被这些RPC框架使用。 典型的应用有：阿里分布式服务框架`Dubbo`的`RPC`框架使用`Dubbo`协议进行节点间通信，
`Dubbo`协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。

* **游戏行业**: 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用。Netty作为高性能的基础通信组件，它本身提供了`TCP/UDP`和`HTTP`协议栈。 非常方便定制和开发私有协议栈，
账号登录服务器，地图服务器之间可以方便的通过Netty进行高性能的通信。

* **大数据领域**: 经典的`Hadoop`的高性能通信和序列化组件`Avro`的`RPC`框架，默认采用Netty进行跨界点通信，它的`Netty Service`基于Netty框架二次封装实现。

## 5、Netty的特点

Netty的对JDK自带的NIO的API进行封装，解决上述问题，主要特点有：

* 设计优雅，适用于各种传输类型的统一API - 阻塞和非阻塞Socket 基于灵活且可扩展的事件模型，可以清晰地分离关注点高度可定制的线程模型 - 单线程，一个或多个线程池真正的无连接数据报套接字支持（自3.1起）
* 高性能 、高吞吐、低延迟、低消耗
* 最小化不必要的内存复制
* 安全 完整的`SSL / TLS`和`StartTLS`支持
* 高并发：Netty 是一款基于 `NIO（Nonblocking IO，非阻塞IO）`开发的网络通信框架，对比于`BIO（Blocking I/O，阻塞IO）`，他的并发性能得到了很大提高。
* 传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。
* 封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。
* 社区活跃，不断更新 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入
* 使用方便 详细记录的Javadoc，用户指南和示例 没有其他依赖项，JDK 5（Netty 3.x）或6（Netty 4.x）就足够了

## 6、Netty 高性能表现在哪些方面？

* **IO 线程模型**：通过多线程`Reactor`反应器模式，在应用层实现异步非阻塞（异步事件驱动）架构，用最少的资源做更多的事。
* **内存零拷贝**：尽量减少不必要的内存拷贝，实现了更高效率的传输。
* **内存池设计**：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。
* **对象池设计**：Java对象可以重用，主要指`Minior GC`非常频繁的对象，如`ByteBuffer`。并且，**对象池使用无锁架构**，性能非常高。
* **mpsc无锁编程**：串形化处理读写, 避免使用锁带来的性能开销。
* **高性能序列化协议**：支持 `protobuf` 等高性能序列化协议。

## 7、BIO、NIO和AIO的区别？

**BIO**：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。

**伪异步IO**：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。

**NIO**：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有`I/O`请求时才启动一个线程进行处理。

**AIO**：一个有效请求一个线程，客户端的`I/O`请求都是由OS先完成了再通知服务器应用去启动线程进行处理，

BIO是面向流的，NIO是面向缓冲区的；

BIO的各种流是阻塞的。而NIO是非阻塞的；

BIO的Stream是单向的，而NIO的channel是双向的。

**NIO的特点**：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于`block`的传输比基于流的传输更高效、更高级的IO函数`zero-copy`、IO多路复用大大提高了Java网络应用
的可伸缩性和实用性。基于`Reactor`线程模型。

在`Reactor`模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。

如在`Reactor`中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

## 8、Netty 和 Tomcat 的区别？

* 作用不同：Tomcat 是 `Servlet` 容器，可以视为 Web 服务器，而 Netty 是异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如TCP和UDP套接字服务器。
* 协议不同：Tomcat 是基于 `http` 协议的 Web 服务器，而 Netty 能通过编程自定义各种协议，因为 Netty 本身自己能`编码/解码字节流`，所有 Netty 可以实现，
`HTTP`服务器、`FTP`服务器、`UDP`服务器、`RPC`服务器、`WebSocket`服务器、Redis 的`Proxy`服务器、MySQL 的`Proxy`服务器等等。

## 9、Netty是怎么实现高性能设计的？

Netty作为高性能IO组件的扛鼎制作，高性能设计的核心： 巧妙的结合 `高性能IO模型` 和 `线程模型` ，相得益彰，达到了高性能 、高吞吐、低延迟、低消耗的目标

其I/O模型 `高性能epoll/select` 模型; 其线程模型为 `多线程reactor反应器模型`。

**I/O模型决定如何收发数据，线程模型决定如何处理数据**。相得益彰，在应用层达到了异步IO的效果。