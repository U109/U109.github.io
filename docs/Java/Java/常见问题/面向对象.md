## 什么是面向对象？

面向对象程序设计是以建立模型体现出来的抽象思维过程和面向对象的方法。我们可以将某个事物抽象出来，赋予它自己的特征，并且可以针对这个事物进行相应的操作，以及规定与其他对象之间的关系。可以降低代码的耦合度，使程序更加灵活。

## 多态的好处

允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用)。即父类型的引用指向子类型的对象。主要有以下优点：

* **可替换性**：多态对已存在代码具有可替换性
* **可扩充性**：增加新的子类不影响已经存在的类结构
* **更加灵活**

## 面向对象三大特性？

其中Java 面向对象编程三大特性：`封装` `继承` `多态`

### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

封装隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

关于继承如下 3 点：

1. 子类拥有父类非 private 的属性和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

### 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，
必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：**继承**（多个子类对同一方法的重写）和**接口**（实现接口并覆盖接口中同一方法）。

方法重载（`overload`）实现的是**编译时的多态性**（也称为前绑定），而方法重写（`override`）实现的是**运行时的多态性**（也称为后绑定）。

一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：

* 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
* 对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

## 什么是多态机制？

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，
该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，
从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，
它是通过动态绑定来实现的，也就是我们所说的多态性。

## 多态的实现

Java实现多态有三个必要条件：`继承`、`重写`、`向上转型`。
* **继承**：在多态中必须存在有继承关系的子类和父类。
* **重写**：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
* **向上转型**：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。

## 面向对象五大基本原则是什么?

* **单一职责原则SRP(Single Responsibility Principle)**: 类的功能要单一，不能包罗万象。
* **开放封闭原则OCP(Open－Close Principle)**: 一个模块对于拓展是开放的，对于修改是封闭的。
* **里式替换原则LSP(the Liskov Substitution Principle LSP)**: 子类可以替换父类出现在父类能够出现的任何地方。
* **依赖倒置原则DIP(the Dependency Inversion Principle DIP)**: 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
* **接口分离原则ISP(the Interface Segregation Principle ISP)**: 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。

## 什么是值传递和引用传递？

* **值传递**，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。
* **引用传递**，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。

一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。

## 接口和抽象类的区别

|比较|                       抽象类                       |                 接口                 |
|---|:-----------------------------------------------:|:----------------------------------:|
|默认方法|                  抽象类可以有默认的方法实现                  |        java 8之前,接口中不存在方法的实现        |
|实现方式|子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现| 子类使用implements来实现接口,需要提供接口中所有声明的实现 |
|构造器|                    抽象类可以有构造器                    |              接口不能有构造器              |
|访问修饰符|       抽象方法可以有public,protected和default等修饰        |       接口默认是public,不能使用其他修饰符        |
|多继承|                   一个类只能继承一个抽象类                   |            一个类可以继承多个接口             |
|访问新方法|抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码|如果往接口中添加新方法,则子类中需要实现该方法|

## 父类的静态方法能否被子类重写

**不能**。重写只适用于实例方法,不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏。