# const

有的时候我们可以通过主键列来定位一条记录，比方说这个查询：

```sql
SELECT * FROM single_table WHERE id = 1438;
```

MySQL会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：

![img.png](/数据库/MySQL/单表访问方法/img.png)

原谅我把聚簇索引对应的复杂的`B+`树结构搞了一个极度精简版，为了突出重点，我们忽略掉了页的结构，直接把所有的叶子节点的记录都放在一起展示，而且记录中只展示我们关心的索引列，
对于`single_table`表的聚簇索引来说，展示的就是`id`列。我们想突出的重点就是：`B+`树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的`B+`树叶子节点中的记录就是按照`id`列排序的。
`B+`树本来就是一个矮矮的大胖子，所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下边这个查询：

```sql
SELECT * FROM single_table WHERE key2 = 3841;
```

这个查询的执行过程的示意图就是这样：

![img_1.png](/数据库/MySQL/单表访问方法/img_1.png)

可以看到这个查询的执行分两步，第一步先从`idx_key2`对应的`B+`树索引中根据`key2`列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的`id`值到聚簇索引中获取到完整的用户记录。

设计MySQL的大叔认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：`const`，意思是`常数级别`的，
代价是可以忽略不计的。不过这种`const`访问方法**只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效**，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，
这个`const`访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。

对于唯一二级索引来说，查询该列为`NULL`值的情况比较特殊，比如这样：

```sql
SELECT * FROM single_table WHERE key2 IS NULL;
```

因为唯一二级索引列并不限制 `NULL` 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用`const`访问方法来执行（至于是什么访问方法我们下边马上说）。









