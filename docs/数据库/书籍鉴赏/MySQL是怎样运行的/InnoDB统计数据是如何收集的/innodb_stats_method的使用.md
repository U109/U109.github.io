# innodb_stats_method的使用

我们知道索引列不重复的值的数量这个统计数据对于MySQL查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：

* 单表查询中单点区间太多，比方说这样：

    ```sql
    SELECT * FROM tbl_name WHERE key IN ('xx1', 'xx2', ..., 'xxn');
    ```

    当`IN`里的参数数量过多时，采用`index dive`的方式直接访问`B+`树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。

* 连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用`ref`访问方法来对被驱动表进行查询，比方说这样：

    ```sql
    SELECT * FROM t1 JOIN t2 ON t1.column = t2.key WHERE ...;
    ```

    在真正执行对`t2`表的查询前，`t1.comumn`的值是不确定的，所以我们也不能通过`index dive`的方式直接访问`B+`树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。


在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现`NULL`值怎么办，比方说某个索引列的内容是这样：

```shell
+------+
| col  |
+------+
|    1 |
|    2 |
| NULL |
| NULL |
+------+
```

此时计算这个col列中不重复的值的数量就有下边的分歧：

* 有的人认为`NULL`值代表一个未确定的值，所以设计MySQL的大叔才认为任何和`NULL`值做比较的表达式的值都为`NULL`，就是这样：

    ```shell
    mysql> SELECT 1 = NULL;
    +----------+
    | 1 = NULL |
    +----------+
    |     NULL |
    +----------+
    1 row in set (0.00 sec)
    
    mysql> SELECT 1 != NULL;
    +-----------+
    | 1 != NULL |
    +-----------+
    |      NULL |
    +-----------+
    1 row in set (0.00 sec)
    
    mysql> SELECT NULL = NULL;
    +-------------+
    | NULL = NULL |
    +-------------+
    |        NULL |
    +-------------+
    1 row in set (0.00 sec)
    
    mysql> SELECT NULL != NULL;
    +--------------+
    | NULL != NULL |
    +--------------+
    |         NULL |
    +--------------+
    1 row in set (0.00 sec)
    ```

    所以每一个`NULL`值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把`NULL`值当作一个独立的值，所以`col`列的不重复的值的数量就是：`4`（分别是`1`、`2`、`NULL`、`NULL`这四个值）。

* 有的人认为其实`NULL`值在业务上就是代表没有，所有的`NULL`值代表的意义是一样的，所以`col`列不重复的值的数量就是：`3`（分别是`1`、`2`、`NULL`这三个值）。

* 有的人认为这`NULL`完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以`col`列不重复的值的数量就是：`2`（分别是`1`、`2`这两个值）。

设计MySQL的大叔蛮贴心的，他们提供了一个名为`innodb_stats_method`的系统变量，相当于在计算某个索引列不重复值的数量时如何对待`NULL`值这个锅甩给了用户，这个系统变量有三个候选值：

* `nulls_equal`：认为所有`NULL`值都是相等的。这个值也是`innodb_stats_method`的默认值。

    如果某个索引列中`NULL`值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。

* `nulls_unequal`：认为所有`NULL`值都是不相等的。

    如果某个索引列中`NULL`值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。

* `nulls_ignored`：直接把`NULL`值忽略掉。

反正这个锅是甩给用户了，当你选定了`innodb_stats_method`值之后，优化器即使选择了不是最优的执行计划，那也跟设计MySQL的大叔们没关系了哈～ 当然对于用户的我们来说，
最好不在索引列中存放`NULL`值才是正解。