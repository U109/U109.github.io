# 连接查询的成本

## 准备工作

连接查询至少是要有两个表的，只有一个`single_table`表是不够的，所以为了故事的顺利发展，我们直接构造一个和`single_table`表一模一样的`single_table2`表。为了简便起见，
我们把`single_table`表称为`s1`表，把`single_table2`表称为`s2`表。

## Condition filtering介绍

我们前边说过，MySQL中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：

* 单次查询驱动表的成本

* 多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）

我们把对驱动表进行查询后得到的记录条数称之为驱动表的`扇出`（英文名：`fanout`）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。
当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：

* 查询一：

```sql
SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2;
```

假设使用`s1`表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，
统计数据中`s1`表的记录行数是`9693`，也就是说优化器就直接会把`9693`当作在`s1`表的扇出值。

* 查询二：

```sql
SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2
WHERE s1.key2 >10 AND s1.key2 < 1000;
```

仍然假设`s1`表是驱动表的话，很显然对驱动表的单表查询可以使用`idx_key2`索引执行查询。此时`idx_key2`的范围区间`(10, 1000)`中有多少条记录，那么扇出值就是多少。我们前边计算过，
满足`idx_key2`的范围区间`(10, 1000)`的记录数是`95`条，也就是说本查询中优化器会把`95`当作驱动表`s1`的扇出值。

事情当然不会总是一帆风顺的，要不然剧情就太平淡了。有的时候扇出值的计算就变得很棘手，比方说下边几个查询：

* 查询三：

```sql
SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2
WHERE s1.common_field > 'xyz';
```

本查询和查询一类似，只不过对于驱动表`s1`多了一个`common_field > 'xyz'`的搜索条件。查询优化器又不会真正的去执行查询，所以它只能猜这`9693`记录里有多少条记录满足`common_field > 'xyz'`条件。

* 查询四：

```sql
SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2
WHERE s1.key2 > 10 AND s1.key2 < 1000 AND
s1.common_field > 'xyz';
```

本查询和查询二类似，只不过对于驱动表`s1`也多了一个`common_field > 'xyz'`的搜索条件。不过因为本查询可以使用`idx_key2`索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合`common_field > 'xyz'`条件，
也就是只需要猜在`95`条记录中有多少符合`common_field > 'xyz'`条件。

* 查询五：

```sql
SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2
WHERE s1.key2 > 10 AND s1.key2 < 1000 AND
s1.key1 IN ('a', 'b', 'c') AND
s1.common_field > 'xyz';
```

本查询和查询二类似，不过在驱动表`s1`选取`idx_key2`索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件：

&emsp; 1、`key1 IN ('a', 'b', 'c')`

&emsp; 2、`common_field > 'xyz'`

也就是优化器需要猜在`95`条记录中有多少符合上述两个条件的。

说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠`猜`：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。

* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

设计MySQL的大叔把这个`猜`的过程称之为`condition filtering`。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是设计MySQL的大叔单纯的瞎猜，整个评估过程挺复杂的，
再仔细的唠叨一遍可能引起大家的生理不适，所以我们就跳过了哈。

:::tip 小贴士
在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。
在MySQL 5.7中，设计MySQL的大叔引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。
我们所说的纯粹瞎猜其实是很不严谨的，设计MySQL的大叔们称之为启发式规则（heuristic），大家有兴趣的可以再深入了解一下哈。
:::

## 两表连接的成本分析

连接查询的成本计算公式是这样的：

```sql
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本
```

对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：

* 分别为驱动表和被驱动表选择成本最低的访问方法。

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。

* 然后分别为驱动表和被驱动表选择成本最低的访问方法。

很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。

:::tip 小贴士
左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询，我们在之后的章节中会仔细唠叨的，稍安勿躁。
:::

比如对于下边这个查询来说：

```sql
SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2
ON s1.key1 = s2.common_field
WHERE s1.key2 > 10 AND s1.key2 < 1000 AND
s2.key2 > 1000 AND s2.key2 < 2000;
```

可以选择的连接顺序有两种：

* `s1`连接`s2`，也就是`s1`作为驱动表，`s2`作为被驱动表。

* `s2`连接`s1`，也就是`s2`作为驱动表，`s1`作为被驱动表。

查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，
不像分析单表查询那样定量的分析了）：

* 使用`s1`作为驱动表的情况

&emsp;  1、分析对于驱动表的成本最低的执行方案

&emsp;  首先看一下涉及`s1`表单表的搜索条件有哪些：

&emsp; &emsp;  1、`s1.key2 > 10 AND s1.key2 < 1000`

&emsp; &emsp;  所以这个查询可能使用到`idx_key2`索引，从全表扫描和使用`idx_key2`这两个方案中选出成本最低的那个，这个过程我们上边都唠叨过了，很显然使用`idx_key2`执行查询的成本更低些。

&emsp;  2、然后分析对于被驱动表的成本最低的执行方案

&emsp;  此时涉及被驱动表`s2`的搜索条件就是：

&emsp; &emsp;  1、`s2.common_field = 常数`（这是因为对驱动表s1结果集中的每一条记录，都需要进行一次被驱动表`s2`的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表`s2`了。）

&emsp; &emsp;  2、`s2.key2 > 1000 AND s2.key2 < 2000`

&emsp;  很显然，第一个条件由于`common_field`没有用到索引，所以并没有什么卵用，此时访问s2表时可用的方案也是`全表扫描`和使用`idx_key2`两种，假设使用`idx_key2`的成本更小。

所以此时使用`s1`作为驱动表时的总成本就是（暂时不考虑使用`join buffer`对成本的影响）：

```sql
使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本
```

* 使用s2作为驱动表的情况

&emsp;  1、分析对于驱动表的成本最低的执行方案

&emsp;  首先看一下涉及`s2`表单表的搜索条件有哪些：

&emsp; &emsp;  1、`s2.key2 > 1000 AND s2.key2 < 2000`

&emsp;  所以这个查询可能使用到`idx_key2`索引，从全表扫描和使用`idx_key2`这两个方案中选出成本最低的那个，假设使用`idx_key2`执行查询的成本更低些。

&emsp;  2、然后分析对于被驱动表的成本最低的执行方案

&emsp;  此时涉及被驱动表`s1`的搜索条件就是：

&emsp; &emsp;  1、`s1.key1 = 常数`

&emsp; &emsp;  2、`s1.key2 > 10 AND s1.key2 < 2000`

&emsp;  这时就很有趣了，使用`idx_key1`可以进行`ref`方式的访问，使用`idx_key2`可以使用`range`方式的访问。这是优化器需要从全表扫描、使用`idx_key1`、
使用`idx_key2`这几个方案里选出一个成本最低的方案。这里有个问题啊，因为`idx_key2`的范围区间是确定的：`(10, 1000)`，怎么计算使用`idx_key2`的成本我们上边已经说过了，
可是在没有真正执行查询前，`s1.key1 = 常数`中的常数值我们是不知道的，怎么衡量使用`idx_key1`执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。
一般情况下，`ref`的访问方式要比`range`成本更低，这里假设使用`idx_key1`进行对`s1`的访问。

所以此时使用`s2`作为驱动表时的总成本就是：

```sql
使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本
```

最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是`驱动表扇出数 x 单次访问被驱动表的成本`，
所以我们的优化重点其实是下边这两个部分：

* 尽量减少驱动表的扇出

* 对被驱动表的访问成本尽量低

这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用`ref`访问方法来降低访问被驱动表的成本了。如果可以，
被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。

## 多表连接的成本分析
首先要考虑一下多表连接时可能产生出多少种连接顺序：

* 对于两表连接，比如表`A`和表`B`连接

只有 `AB`、`BA`这两种连接顺序。其实相当于`2 × 1 = 2`种连接顺序。

* 对于三表连接，比如表`A`、表`B`、表`C`进行连接

有`ABC`、`ACB`、`BAC`、`BCA`、`CAB`、`CBA`这么`6`种连接顺序。其实相当于`3 × 2 × 1 = 6`种连接顺序。

* 对于四表连接的话，则会有`4 × 3 × 2 × 1 = 24`种连接顺序。

* 对于`n`表连接的话，则有` n × (n-1) × (n-2) × ··· × 1`种连接顺序，就是`n`的阶乘种连接顺序，也就是`n`!。

有`n`个表进行连接，MySQL查询优化器要每一种连接顺序的成本都计算一遍么？那可是`n`!种连接顺序呀。其实真的是要都算一遍，不过设计MySQL的大叔们想了很多办法减少计算非常多种连接顺序的成本的方法：

* 提前结束某种顺序的成本评估

MySQL在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，
那就压根儿不对该连接顺序继续往下分析了。比方说`A、B、C`三个表进行连接，已经得到连接顺序`ABC`是当前的最小连接成本，比方说`10.0`，在计算连接顺序`BCA`时，发现`B`和`C`的连接成本就已经大于`10.0`时，
就不再继续往后分析`BCA`这个连接顺序的成本了。

* 系统变量`optimizer_search_depth`

为了防止无穷无尽的分析各种连接顺序的成本，设计MySQL的大叔们提出了`optimizer_search_depth`系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，
否则只对与`optimizer_search_depth`值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，
但可以省掉很多分析连接成本的时间。

* 根据某些规则压根儿就不考虑某些连接顺序

即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计MySQL的大叔干脆提出了一些所谓的启发式规则（就是根据以往经验指定的一些规则），
凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量`optimizer_prune_level`来控制到底是不是用这些启发式规则。