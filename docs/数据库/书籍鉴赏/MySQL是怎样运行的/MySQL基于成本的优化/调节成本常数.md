# 调节成本常数

我们前边已经介绍了两个`成本常数`：

* 读取一个页面花费的成本默认是`1.0`
* 检测一条记录是否符合搜索条件的成本默认是`0.2`

其实除了这两个成本常数，MySQL还支持好多呢，它们被存储到了mysql数据库（这是一个系统数据库，我们之前介绍过）的两个表中：

```sql
mysql> SHOW TABLES FROM mysql LIKE '%cost%';
+--------------------------+
| Tables_in_mysql (%cost%) |
+--------------------------+
| engine_cost              |
| server_cost              |
+--------------------------+
2 rows in set (0.00 sec)
```

我们在第一章中就说过，一条语句的执行其实是分为两层的：

* `server`层

* 存储引擎层

在`server`层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在`server`层中执行的成本是和它操作的表使用的存储引擎是没关系的，
所以关于这些操作对应的成本常数就存储在了`server_cost`表中，而依赖于存储引擎的一些操作对应的成本常数就存储在了`engine_cost`表中。

## mysql.server_cost表

`server_cost`表中在`server`层进行的一些操作对应的成本常数，具体内容如下：

```sql
mysql> SELECT * FROM mysql.server_cost;
+------------------------------+------------+---------------------+---------+
| cost_name                    | cost_value | last_update         | comment |
+------------------------------+------------+---------------------+---------+
| disk_temptable_create_cost   |       NULL | 2018-01-20 12:03:21 | NULL    |
| disk_temptable_row_cost      |       NULL | 2018-01-20 12:03:21 | NULL    |
| key_compare_cost             |       NULL | 2018-01-20 12:03:21 | NULL    |
| memory_temptable_create_cost |       NULL | 2018-01-20 12:03:21 | NULL    |
| memory_temptable_row_cost    |       NULL | 2018-01-20 12:03:21 | NULL    |
| row_evaluate_cost            |       NULL | 2018-01-20 12:03:21 | NULL    |
+------------------------------+------------+---------------------+---------+
6 rows in set (0.05 sec)
```

我们先看一下`server_cost`各个列都分别是什么意思：

* `cost_name`

表示成本常数的名称。

* `cost_value`

表示成本常数对应的值。如果该列的值为`NULL`的话，意味着对应的成本常数会采用默认值。

* `last_update`

表示最后更新记录的时间。

* `comment`

注释。

从`server_cost`中的内容可以看出来，目前在`server`层的一些操作对应的成本常数有以下几种：

|成本常数名称|默认值| 描述                                                                         |
|:--|:--|:---------------------------------------------------------------------------|
|disk_temptable_create_cost|40.0| 创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。                                |
|disk_temptable_row_cost|1.0| 向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。                        |
|key_compare_cost|0.1| 两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升filesort的成本，让优化器可能更倾向于使用索引完成排序而不是filesort。|
|memory_temptable_create_cost|2.0| 创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。                                |
|memory_temptable_row_cost|0.2| 向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表                         |
|row_evaluate_cost|0.2| 这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。               |

:::tip 小贴士
MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询
（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，
也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。关于更多临时表的细节我们并不打算展开唠叨，因为展开可能又需要好几万字了，
大家知道创建临时表和对这个临时表进行写入和读取的操作代价还是很高的就行了。
:::

这些成本常数在`server_cost`中的初始值都是`NULL`，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：

* 对我们感兴趣的成本常数做更新操作

比方说我们想把检测一条记录是否符合搜索条件的成本增大到`0.4`，那么就可以这样写更新语句：

```sql
UPDATE mysql.server_cost
SET cost_value = 0.4
WHERE cost_name = 'row_evaluate_cost';
```

* 让系统重新加载这个表的值。

使用下边语句即可：

```sql
FLUSH OPTIMIZER_COSTS;
```

当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把`cost_value`的值设置为`NULL`，再使用`FLUSH OPTIMIZER_COSTS`语句让系统重新加载它就好了。

## mysql.engine_cost表

`engine_cost`表表中在存储引擎层进行的一些操作对应的成本常数，具体内容如下：

```sql
mysql> SELECT * FROM mysql.engine_cost;
+-------------+-------------+------------------------+------------+---------------------+---------+
| engine_name | device_type | cost_name              | cost_value | last_update         | comment |
+-------------+-------------+------------------------+------------+---------------------+---------+
| default     |           0 | io_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |
| default     |           0 | memory_block_read_cost |       NULL | 2018-01-20 12:03:21 | NULL    |
+-------------+-------------+------------------------+------------+---------------------+---------+
2 rows in set (0.05 sec)
```

与`server_cost`相比，`engine_cost`多了两个列：

* `engine_name`列

指成本常数适用的存储引擎名称。如果该值为`default`，意味着对应的成本常数适用于所有的存储引擎。

* `device_type`列

指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在`MySQL 5.7.21`这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是`0`。

我们从`engine_cost`表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：

|成本常数名称|默认值| 描述                                                                                                                                     |
|:--|:--|:---------------------------------------------------------------------------------------------------------------------------------------|
|io_block_read_cost|1.0| 从磁盘上读取一个块对应的成本。请注意我使用的是块，而不是页这个词儿。对于InnoDB存储引擎来说，一个页就是一个块，不过对于MyISAM存储引擎来说，默认是以4096字节作为一个块的。增大这个值会加重I/O成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。|
|memory_block_read_cost|1.0| 与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。                                                                                                        |


大家看完这两个成本常数的默认值是不是有些疑惑，怎么从内存中和从磁盘上读取一个块的默认成本是一样的，脑子瓦特了？这主要是因为在MySQL目前的实现中，
并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以设计MySQL的大叔们很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是`1.0`，
不过随着MySQL的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。

与更新`server_cost`表中的记录一样，我们也可以通过更新engine_cost表中的记录来更改关于存储引擎的成本常数，我们也可以通过为engine_cost表插入新记录的方式来添加只针对某种存储引擎的成本常数：

* 插入针对某个存储引擎的成本常数

比如我们想增大`InnoDB`存储引擎页面`I/O`的成本，书写正常的插入语句即可：

```sql
INSERT INTO mysql.engine_cost
VALUES ('InnoDB', 0, 'io_block_read_cost', 2.0,
CURRENT_TIMESTAMP, 'increase Innodb I/O cost');
```

* 让系统重新加载这个表的值。

使用下边语句即可：

```sql
FLUSH OPTIMIZER_COSTS;
```