# File Header（文件头部）

上边唠叨的`Page Header`
是专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的`File Header`
针对各种类型的页都通用，也就是说不同类型的页都会以`File Header`作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，
比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的38个字节，是由下边这些内容组成的：

|                名称                 | 占用空间大小 |                     描述                      |
|:---------------------------------:|:------:|:-------------------------------------------:|
|     FIL_PAGE_SPACE_OR_CHKSUM	     |  4字节   |              	页的校验和（checksum值）              |
|         FIL_PAGE_OFFSET	          |  4字节	  |                     页号                      |
|          FIL_PAGE_PREV	           |  4字节	  |                   上一个页的页号                   |
|          FIL_PAGE_NEXT	           |  4字节	  |                   下一个页的页号                   |
|           FIL_PAGE_LSN	           |  8字节	  | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
|          FIL_PAGE_TYPE	           |  2字节	  |                    该页的类型                    |
|     FIL_PAGE_FILE_FLUSH_LSN	      |  8字节	  |                仅在系统表空间的一个页中                 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID	 |  4字节	  |                  页属于哪个表空间                   |

对照着这个表格，我们看几个目前比较重要的部分：

* `FIL_PAGE_SPACE_OR_CHKSUM`

这个代表当前页面的校验和（`checksum`
）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为`校验和`。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，
所以省去了直接比较两个比较长的字节串的时间损耗。

* `FIL_PAGE_OFFSET`

每一个`页`都有一个单独的页号，就跟你的身份证号码一样，`InnoDB`通过页号来可以唯一定位一个页。

* `FIL_PAGE_TYPE`

这个代表当前页的类型，我们前边说过，`InnoDB`为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：

| 类型名称	| 十六进制	| 描述 |
|:---------:|:------:|:----:|
| FIL_PAGE_TYPE_ALLOCATED	| 0x0000	| 最新分配，还没使用 |
| FIL_PAGE_UNDO_LOG	| 0x0002	| Undo日志页 |
| FIL_PAGE_INODE	| 0x0003	| 段信息节点 |
| FIL_PAGE_IBUF_FREE_LIST	| 0x0004	| Insert Buffer空闲列表 |
| FIL_PAGE_IBUF_BITMAP	| 0x0005	| Insert Buffer位图 |
| FIL_PAGE_TYPE_SYS	| 0x0006	| 系统页 |
| FIL_PAGE_TYPE_TRX_SYS	| 0x0007	| 事务系统数据 |
| FIL_PAGE_TYPE_FSP_HDR	| 0x0008	| 表空间头部信息 |
| FIL_PAGE_TYPE_XDES	| 0x0009	| 扩展描述页 |
| FIL_PAGE_TYPE_BLOB	| 0x000A	| 溢出页 |
| FIL_PAGE_INDEX	| 0x45BF	| 索引页，也就是我们所说的数据页 |

我们存放记录的数据页的类型其实是FIL_PAGE_INDEX，也就是所谓的索引页。

* `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

我们前边强调过，`InnoDB`都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），`InnoDB`可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，
`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，
不过我们本集中唠叨的数据页（也就是类型为`FIL_PAGE_INDEX`的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：

![img.png](/数据库/MySQL/InnoDB数据页结构/img-14.png)

关于`File Header`的其他属性我们暂时用不到，等用到的时候再提哈～
