# 回表的代价

上边的讨论对`回表`这个词儿多是一带而过，可能大家没啥深刻的体会，下边我们详细唠叨下。还是用`idx_name_birthday_phone_number`索引为例，看下边这个查询：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```
在使用`idx_name_birthday_phone_number`索引进行查询时大致可以分为这两个步骤：

1. 从索引`idx_name_birthday_phone_number`对应的`B+`树中取出`name`值在`Asa～Barlow`之间的用户记录。

2. 由于索引`idx_name_birthday_phone_number`对应的`B+`树用户记录中只包含`name`、`birthday`、`phone_number`、`id`这4个字段，而查询列表是`*`，意味着要查询表中所有字段，也就是还要包括`country`字段。
这时需要把从上一步中获取到的每一条记录的`id`字段都到聚簇索引对应的`B+`树中找到完整的用户记录，也就是我们通常所说的`回表`，然后把完整的用户记录返回给查询用户。

由于索引`idx_name_birthday_phone_number`对应的`B+`树中的记录首先会按照`name`列的值进行排序，所以值在`Asa～Barlow`之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，
这种读取方式我们也可以称为`顺序I/O`。根据第1步中获取到的记录的`id`字段的值可能并不相连，而在聚簇索引中记录是根据`id`（也就是主键）的顺序排列的，所以根据这些并不连续的`id`值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，
这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为`随机I/O`。一般情况下，`顺序I/O`比`随机I/O`的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引`idx_name_birthday_phone_number`的查询有这么两个特点：

* 会使用到两个`B+`树索引，一个`二级索引`，一个`聚簇索引`。

* 访问`二级索引`使用`顺序I/O`，访问`聚簇索引`使用`随机I/O`。

需要`回表`的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。比方说`name`值在`Asa～Barlow`之间的用户记录数量占全部记录数量`90%`以上，那么如果使用`idx_name_birthday_phone_number`索引的话，有`90%`多的`id`值需要回表，
这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

那什么时候采用全表扫描的方式，什么时候使用采用`二级索引 + 回表`的方式去执行查询呢？这个就是传说中的`查询优化器`做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，
需要`回表`的记录数越多，就越倾向于使用全表扫描，反之倾向于使用`二级索引 + 回表`的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用`二级索引 + 回表`的方式进行查询，
因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
```
添加了`LIMIT 10`的查询更容易让优化器采用`二级索引 + 回表`的方式进行查询。

对于有排序需求的查询，上边讨论的采用`全表扫描`还是`二级索引 + 回表`的方式进行查询的条件也是成立的，比方说下边这个查询：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number;
```
由于查询列表是`*`，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（`filesort`）低，所以优化器会倾向于使用全表扫描的方式执行查询。如果我们加了`LIMIT`子句，比如这样：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```
这样需要`回表`的记录特别少，优化器就会倾向于使用`二级索引 + 回表`的方式执行查询。

## 覆盖索引

为了彻底告别`回表`操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列，比如这样：

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```
因为我们只查询`name`, `birthday`, `phone_number`这三个索引列的值，所以在通过`idx_name_birthday_phone_number`索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是`country`列的值了，这样就省去了回表操作带来的性能损耗。
我们把这种只需要用到索引的查询方式称为`索引覆盖`。排序操作也优先使用覆盖索引的方式进行查询，比方说这个查询：

```sql
SELECT name, birthday, phone_number  FROM person_info ORDER BY name, birthday, phone_number;
```
虽然这个查询中没有`LIMIT`子句，但是采用了`覆盖索引`，所以查询优化器就会直接使用`idx_name_birthday_phone_number`索引进行排序而不需要`回表`操作了。

当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用`*`号作为查询列表，最好把我们需要查询的列依次标明。