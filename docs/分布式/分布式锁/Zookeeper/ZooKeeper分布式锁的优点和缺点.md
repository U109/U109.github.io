总结一下ZooKeeper分布式锁：

* **优点**：ZooKeeper分布式锁（如`InterProcessMutex`），能有效的解决分布式问题，不可重入问题，使用起来也较为简单。

* **缺点**：ZooKeeper实现的分布式锁，性能并不太高。为啥呢？

    因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过`Leader`服务器来执行，然后`Leader`服务器还需要将数据同不到所有的`Follower`机器上，这样频繁的网络通信，性能的短板是非常突出的。 

    总之，在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper的高可用特性，所以在并发量不是太高的场景，推荐使用ZooKeeper的分布式锁。

在目前分布式锁实现方案中，比较成熟、主流的方案有两种：

**1. 基于Redis的分布式锁**

**2. 基于ZooKeeper的分布式锁**

两种锁，分别适用的场景为：

1. 基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景；

2. 基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。

总之，这里没有谁好谁坏的问题，而是谁更合适的问题。

最后对本章的内容做个总结：在分布式系统中，ZooKeeper是一个重要的协调工具。本章介绍了分布式命名服务、分布式锁的原理以及基于ZooKeeper的参考实现。本章的那些实战案例，建议大家自己去动手掌握，无论是应用实际开始、还是大公司面试，都是非常有用的。
另外，主流的分布式协调中间件，也不仅仅只有Zookeeper，还有非常著名的Etcd中间件。但是从学习的层面来说，二者之间的功能设计、核心原理都是差不多的，掌握了Zookeeper，Etcd的上手使用也是很容易的。