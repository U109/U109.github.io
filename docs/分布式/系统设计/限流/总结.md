这篇文章介绍实现限流的几种方式，主要是窗口算法和桶算法，两者各有优势。

- 窗口算法实现简单，逻辑清晰，可以很直观的得到当前的 QPS 情况，但是会有时间窗口的临界突变问题，而且不像桶一样有队列可以缓冲。

- 桶算法虽然稍微复杂，不好统计 QPS 情况，但是桶算法也有优势所在。
  - 漏桶模式消费速率恒定，可以很好的保护自身系统，可以对流量进行整形，但是面对突发流量不能快速响应。
  - 令牌桶模式可以面对突发流量，但是启动时会有缓慢加速的过程，不过常见的开源工具中已经对此优化。

## 单机限流与分布式限流

上面演示的基于代码形式的窗口算法和桶算法限流都适用于单机限流，如果需要分布式限流可以结合注册中心、负载均衡计算每个服务的限流阈值，但这样会降低一定精度，如果对精度要求不是太高，可以使用。
而 Redis 的限流，由于 Redis 的单机性，本身就可以用于分布式限流。使用 Redis 可以实现各种可以用于限流算法，如果觉得麻烦也可以使用开源工具如 `redisson`，已经封装了基于 Redis 的限流。

## 其他限流工具

文中已经提到了 `Guava` 的限流工具包，不过它毕竟是单机的，开源社区中也有很多分布式限流工具，如阿里开源的 `Sentinel` 就是不错的工具，`Sentinel` 以流量为切入点，
从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。