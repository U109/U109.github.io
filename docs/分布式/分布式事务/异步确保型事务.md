指将一系列同步的事务操作修改为基于消息队列异步执行的操作，来避免分布式事务中同步阻塞带来的数据操作性能的下降。

## MQ事务消息方案

基于MQ的事务消息方案主要依靠MQ的**半消息机制**来实现投递消息和参与者自身本地事务的一致性保障。半消息机制实现原理其实借鉴的2PC的思路，是二阶段提交的广义拓展。

> **半消息**：在原有队列消息执行后的逻辑，如果后面的本地逻辑出错，则不发送该消息，如果通过则告知MQ发送；

![img_31.png](img_31.png)

1. 事务发起方首先发送半消息到MQ；

2. MQ通知发送方消息发送成功；

3. 在发送半消息成功后执行本地事务；

4. 根据本地事务执行结果返回`commit`或者是`rollback`；

5. 如果消息是`rollback`, MQ将丢弃该消息不投递；如果是`commit`，MQ将会消息发送给消息订阅方；

6. 订阅方根据消息执行本地事务；

7. 订阅方执行本地事务成功后再从MQ中将该消息标记为已消费；

8. 如果执行本地事务过程中，执行端挂掉，或者超时，MQ服务器端将不停的询问`producer`来获取事务状态；

9. `Consumer`端的消费成功机制有MQ保证；

## 异步确保型事务使用示例

举个例子，假设存在业务规则：某笔订单成功后，为用户加一定的积分。

在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。

从这个过程可以看到，基于消息队列实现的事务存在以下操作：

1. 订单服务创建订单，提交本地事务
2. 订单服务发布一条消息
3. 积分服务收到消息后加积分

![img_32.png](img_32.png)

我们可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：

* 编写订单服务里订单创建的逻辑
* 编写积分服务里增加积分的逻辑

可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程

因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。

## 基于阿里 RocketMQ实现MQ异步确保型事务

有一些第三方的MQ是支持事务消息的，这些消息队列，支持半消息机制，比如`RocketMQ`，`ActiveMQ`。但是有一些常用的MQ也不支持事务消息，比如 `RabbitMQ` 和 `Kafka` 都不支持。

以阿里的 `RocketMQ` 中间件为例，其思路大致为：

1. `producer`(本例中指A系统)发送半消息到`broker`，这个半消息不是说消息内容不完整， 它包含完整的消息内容， 在`producer`端和普通消息的发送逻辑一致

2. `broker`存储半消息，半消息存储逻辑与普通消息一致，只是属性有所不同，`topic`是固定的`RMQ_SYS_TRANS_HALF_TOPIC`，`queueId`也是固定为`0`，这个`tiopic`中的消息对消费者是不可见的，
所以里面的消息永远不会被消费。这就保证了在半消息提交成功之前，消费者是消费不到这个半消息的

3. `broker`端半消息存储成功并返回后，A系统执行本地事务，并根据本地事务的执行结果来决定半消息的提交状态为提交或者回滚

4. A系统发送结束半消息的请求，并带上提交状态(提交 or 回滚)

5. `broker`端收到请求后，首先从`RMQ_SYS_TRANS_HALF_TOPIC`的`queue`中查出该消息，设置为完成状态。如果消息状态为提交，
则把半消息从`RMQ_SYS_TRANS_HALF_TOPIC`队列中复制到这个消息原始`topic`的`queue`中去(之后这条消息就能被正常消费了)；如果消息状态为回滚，则什么也不做。

6. `producer`发送的半消息结束请求是 `oneway` 的，也就是发送后就不管了，只靠这个是无法保证半消息一定被提交的，`rocketMq`提供了一个兜底方案，这个方案叫消息反查机制，
`Broker`启动时，会启动一个 `TransactionalMessageCheckService` 任务，该任务会定时从半消息队列中读出所有超时未完成的半消息，针对每条未完成的消息，
`Broker`会给对应的`Producer`发送一个消息反查请求，根据反查结果来决定这个半消息是需要提交还是回滚，或者后面继续来反查。

7. `consumer`(本例中指B系统)消费消息，执行本地数据变更(至于B是否能消费成功，消费失败是否重试，这属于正常消息消费需要考虑的问题)。

![img_33.png](img_33.png)

在`rocketMq`中，不论是`producer`收到`broker`存储半消息成功返回后执行本地事务，还是`broker`向`producer`反查消息状态，都是通过回调机制完成，我把`producer`端的代码贴出来你就明白了：

![img_34.png](img_34.png)

半消息发送时，会传入一个回调类`TransactionListener`，使用时必须实现其中的两个方法:

* `executeLocalTransaction`方法会在`broker`返回半消息存储成功后执行，我们会在其中执行本地事务；
* `checkLocalTransaction`方法会在`broker`向`producer`发起反查时执行，我们会在其中查询库表状态。两个方法的返回值都是消息状态，就是告诉`broker`应该提交或者回滚半消息

![img_35.png](img_35.png)

## 本地消息表方案

有时候我们目前的MQ组件并不支持事务消息，或者我们想尽量少的侵入业务方。这时我们需要另外一种方案**“基于DB本地消息表“**。

本地消息表最初由 `eBay` 提出来解决分布式事务的问题。是目前业界使用的比较多的方案之一，它的核心思想就是将分布式事务拆分成本地事务进行处理。

![img_36.png](img_36.png)

发送消息方：

1. 需要有一个消息表，记录着消息状态相关信息。
2. 业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。直接利用本地事务，将业务数据和事务消息直接写入数据库。
3. 在本地事务中处理完业务数据和写消息表操作后，通过写消息到 MQ 消息队列。使用专门的投递工作线程进行事务消息投递到MQ，根据投递ACK去删除事务消息表记录
4. 消息会发到消息消费方，如果发送失败，即进行重试。

消息消费方：

1. 处理消息队列中的消息，完成自己的业务逻辑。
2. 如果本地事务处理成功，则表明已经处理成功了。
3. 如果本地事务处理失败，那么就会重试执行。
4. 如果是业务层面的失败，给消息生产方发送一个业务补偿消息，通知进行回滚等操作。
5. 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

### 本地消息表优缺点

**优点：**

* 本地消息表建设成本比较低，实现了可靠消息的传递确保了分布式事务的最终一致性。
* 无需提供回查方法，进一步减少的业务的侵入。
* 在某些场景下，还可以进一步利用注解等形式进行解耦，有可能实现无业务代码侵入式的实现。


**缺点：**

* 本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。
* 本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的

## MQ事务消息 VS 本地消息表

### 二者的共性

1. 事务消息都依赖MQ进行事务通知，所以都是异步的。
2. 事务消息在投递方都是存在重复投递的可能，需要有配套的机制去降低重复投递率，实现更友好的消息投递去重。
3. 事务消息的消费方，因为投递重复的无法避免，因此需要进行消费去重设计或者服务幂等设计。

### 二者的区别

**MQ事务消息：**

* 需要MQ支持半消息机制或者类似特性，在重复投递上具有比较好的去重处理；
* 具有比较大的业务侵入性，需要业务方进行改造，提供对应的本地操作成功的回查功能；

**DB本地消息表：**

* 使用了数据库来存储事务消息，降低了对MQ的要求，但是增加了存储成本；
* 事务消息使用了异步投递，增大了消息重复投递的可能性；

|分类|共同点|                    优势                    |                        弊端                        |
|---|:---:|:----------------------------------------:|:------------------------------------------------:|
|本地消息表|都需要自己写业务补偿代码|        一种非常经典的实现，避免了分布式事务，实现最终一致性        |       消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂货需要处理       |
|MQ事务消息|都需要自己写业务补偿代码| 实现最终一致性，不需要依赖本地数据库事务。用消息队列的方式实现分布式事务，效率高 | 目前主流的MQ中有ActiveMQ、RocketMQ支持事务消息，实现难度大，和业务耦合比较紧密 |


