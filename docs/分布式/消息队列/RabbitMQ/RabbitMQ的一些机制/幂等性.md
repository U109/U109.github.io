所谓幂等性就是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。

比如用户购买商品后支付后已经扣款成功，但是返回结果时出现网络异常，用户并不知道自己已经付费成功，于是再次点击按钮，此时就进行了第二次扣款，这次的返回结果成功。但是扣了两次用户的钱，这就出现了不满足幂等性，即用户对统一操作发起了一次或多次请求不一致，
产生了副作用导致用户被多扣费了。

对应消息队列 MQ 中出现的幂等性问题就是消息重复消费。比如消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，
但实际上该消费者已成功消费了该条消息，造成消费者的重复消费。

❓ 怎么解决呢

在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，MQ 消费者的幂等性的解决一般使用**全局ID**，就是每次完成一次操作应该生成一个唯一标识，比如`时间戳`、`UUID`、`消息队列中消息的id号`等等。
这样每次消费消息时都先通过该唯一标识先判断该消息是否已消费过，如果消费过则不再消费，则避免了消息重复消费问题。

业界主流的幂等性解决方案有以下两种操作：

* **指纹码机制**：指纹码是按照一定规则，比如时间戳、其他服务给的唯一信息码而拼接出来的`唯一标识`，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来。然后就利用查询语句进行判断这个指纹码是否存在数据库中，优势就是实现简单，
只需要进行拼接即可，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库会出现写入性能瓶颈，当然也可以采用分库分表提升性能。（不推荐）
* **Redis原子性**：利用 `redis` 执行 `setnx` 命令，天然具有幂等性，从而实现不重复消费。（推荐）